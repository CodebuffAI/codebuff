#!/usr/bin/env bun

import { execFileSync } from 'child_process'
import fs from 'fs'
import path from 'path'

import { promptAiSdkStructured } from '@codebuff/backend/llm-apis/vercel-ai-sdk/ai-sdk'
import { models } from '@codebuff/common/constants'
import { z } from 'zod/v4'

import { extractRepoNameFromUrl, setupTestRepo } from './setup-test-repo'
import { disableLiveUserInputCheck } from '@codebuff/backend/live-user-inputs'

// Types for commit data
export interface CommitInfo {
  sha: string
  author: string
  date: string
  message: string
  stats: {
    filesChanged: number
    insertions: number
    deletions: number
  }
}

export interface FilteredCommit extends CommitInfo {
  githubUrl: string
  reason: string
  shortDescription: string
}

export interface CommitPickerResult {
  repoUrl: string
  repoName: string
  generationDate: string
  totalCommitsScanned: number
  commitsAfterBasicFilter: number
  selectedCommits: FilteredCommit[]
}

// Schema for GPT-5 response
const CommitSelectionSchema = z.object({
  selectedCommits: z.array(
    z.object({
      sha: z.string(),
      reason: z.string(),
      shortDescription: z.string(),
    }),
  ),
})

const COMMIT_SCREENING_PROMPT = `You are an expert at identifying substantial and well-scoped code changes in git commits that would make good evaluation examples for an AI coding assistant.

Given a list of commits, identify which ones represent substantial, complete, and clear changes that would make good coding tasks. Choose approximately 8-15 commits from this batch that meet the criteria.

A good evaluation commit should:
1. Make a meaningful, self-contained change (not just typo fixes or formatting)
2. Have a clear purpose that can be described without implementation details
3. Represent work that a skilled developer could implement given a description
4. Show interesting coding patterns or solve real problems
5. Not be auto-generated, trivial refactoring, or pure dependency updates
6. Have reasonable scope (not too small like 1-line fixes, not too large like massive refactors)

Avoid commits that are:
- Dependency updates (package.json, lock files)
- Auto-generated code (generated files, build outputs)
- Pure formatting or linting changes
- Documentation-only changes (unless they involve code examples)
- Merge commits or reverts
- Trivial one-line fixes
- Mass renaming or file moves without logic changes

For each commit you select:
- Provide a clear reason why it makes a good evaluation example
- Write a short description (1-2 sentences) of what the commit accomplishes

Return your response as JSON with the selected commits.`

const fingerprintId = 'commit-picker'
const userInputId = 'commit-picker'

function getCommits(repoPath: string, limit: number): CommitInfo[] {
  const gitLogOutput = execFileSync(
    'git',
    [
      'log',
      '--pretty=format:%H|%an|%ad|%s',
      '--date=iso',
      '-n',
      limit.toString(),
    ],
    { cwd: repoPath, encoding: 'utf-8' },
  )

  const lines = gitLogOutput.split('\n').filter((line) => line.trim() !== '')

  return lines.map((line) => {
    const [sha, author, date, ...messageParts] = line.split('|')
    const message = messageParts.join('|')

    // Get stats for this commit
    const statsOutput = execFileSync('git', ['show', '--stat', sha], {
      cwd: repoPath,
      encoding: 'utf-8',
    })
    const stats = parseGitStats(statsOutput)

    return {
      sha,
      author,
      date,
      message,
      stats,
    }
  })
}

function parseGitStats(statsOutput: string): {
  filesChanged: number
  insertions: number
  deletions: number
} {
  const statsLine = statsOutput
    .split('\n')
    .find((line) => line.includes('files changed'))

  if (!statsLine) {
    return { filesChanged: 0, insertions: 0, deletions: 0 }
  }

  const filesChanged = parseInt(
    statsLine.match(/(\d+) files? changed/)?.[1] || '0',
  )
  const insertions = parseInt(statsLine.match(/(\d+) insertions?/)?.[1] || '0')
  const deletions = parseInt(statsLine.match(/(\d+) deletions?/)?.[1] || '0')

  return { filesChanged, insertions, deletions }
}

function basicFilter(commits: CommitInfo[]): CommitInfo[] {
  return commits.filter((commit) => {
    const { message, stats } = commit
    const lowerMessage = message.toLowerCase()

    // Filter out obvious non-candidates
    if (
      // Dependency updates
      lowerMessage.includes('update dependencies') ||
      lowerMessage.includes('bump ') ||
      (lowerMessage.includes('upgrade ') && lowerMessage.includes('version')) ||
      // Auto-generated
      lowerMessage.includes('auto-generated') ||
      lowerMessage.includes('generated by') ||
      // Build/CI changes
      lowerMessage.includes('ci:') ||
      lowerMessage.includes('build:') ||
      // Formatting/linting
      (lowerMessage.includes('format') && lowerMessage.includes('code')) ||
      lowerMessage.includes('lint') ||
      lowerMessage.includes('prettier') ||
      // Merge commits
      lowerMessage.startsWith('merge ') ||
      // Reverts
      lowerMessage.startsWith('revert ') ||
      // Documentation only (unless it's substantial)
      (lowerMessage.includes('readme') && stats.filesChanged <= 1) ||
      (lowerMessage.includes('docs:') && stats.filesChanged <= 2)
    ) {
      return false
    }

    // Filter by stats - too small or too large
    if (
      stats.filesChanged === 0 ||
      (stats.filesChanged <= 1 && stats.insertions + stats.deletions < 5) ||
      stats.filesChanged > 50 || // Massive changes
      stats.insertions + stats.deletions > 2000 // Huge diffs
    ) {
      return false
    }

    return true
  })
}

function createGithubUrl(repoUrl: string, sha: string): string {
  // Convert repo URL to GitHub commit URL
  let baseUrl = repoUrl
  if (baseUrl.endsWith('.git')) {
    baseUrl = baseUrl.slice(0, -4)
  }
  if (baseUrl.startsWith('git@github.com:')) {
    baseUrl = baseUrl.replace('git@github.com:', 'https://github.com/')
  }
  return `${baseUrl}/commit/${sha}`
}

async function screenCommitsWithGpt5(
  commits: CommitInfo[],
  repoUrl: string,
  clientSessionId: string,
): Promise<FilteredCommit[]> {
  const batchSize = 25
  const selectedCommits: FilteredCommit[] = []

  for (let i = 0; i < commits.length; i += batchSize) {
    const batch = commits.slice(i, i + batchSize)
    console.log(
      `Screening batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(commits.length / batchSize)} (${batch.length} commits)...`,
    )

    const commitsInfo = batch
      .map(
        (c) =>
          `${c.sha.substring(0, 8)}: ${c.message}\n` +
          `Author: ${c.author}, Date: ${c.date}\n` +
          `Stats: ${c.stats.filesChanged} files changed, +${c.stats.insertions} -${c.stats.deletions}\n`,
      )
      .join('\n\n')

    const prompt = `${COMMIT_SCREENING_PROMPT}\n\nCommits to evaluate:\n\n${commitsInfo}`

    try {
      disableLiveUserInputCheck()
      const response = await promptAiSdkStructured({
        messages: [{ role: 'user', content: prompt }],
        schema: CommitSelectionSchema,
        model: models.openrouter_gpt5,
        clientSessionId,
        fingerprintId,
        userInputId,
        userId: undefined,
      })

      // Handle empty or invalid response
      if (
        !response ||
        !response.selectedCommits ||
        !Array.isArray(response.selectedCommits)
      ) {
        console.log(
          `No valid response from GPT-5 for batch ${Math.floor(i / batchSize) + 1}, skipping...`,
        )
        continue
      }

      // Map selected commits back to full commit info with GitHub URLs
      const batchSelected = batch
        .filter((commit) =>
          response.selectedCommits.some((selected) =>
            commit.sha.startsWith(selected.sha),
          ),
        )
        .map((commit) => {
          const selected = response.selectedCommits.find((s) =>
            commit.sha.startsWith(s.sha),
          )!
          return {
            ...commit,
            githubUrl: createGithubUrl(repoUrl, commit.sha),
            reason: selected.reason,
            shortDescription: selected.shortDescription,
          }
        })

      selectedCommits.push(...batchSelected)
      console.log(`Selected ${batchSelected.length} commits from this batch`)
    } catch (error) {
      console.error(
        `Error screening batch ${Math.floor(i / batchSize) + 1}:`,
        error,
      )
      // Continue with next batch on error
    }

    // Add small delay between batches to be respectful
    await new Promise((resolve) => setTimeout(resolve, 1000))
  }

  return selectedCommits
}
export async function pickCommits({
  repoUrl,
  outputPath,
  clientSessionId,
  limit = 100,
}: {
  repoUrl: string
  outputPath?: string
  clientSessionId: string
  limit?: number
}): Promise<void> {
  const repoName = extractRepoNameFromUrl(repoUrl)
  console.log(`Picking commits from repository: ${repoName}`)
  console.log(`Repository URL: ${repoUrl}`)
  console.log(`Commit limit: ${limit}`)

  // Setup the test repository
  console.log('Cloning repository...')
  const repoPath = await setupTestRepo(repoUrl, repoName)

  // Get commits
  console.log(`Fetching last ${limit} commits...`)
  const allCommits = getCommits(repoPath, limit)
  console.log(`Found ${allCommits.length} commits`)

  // Apply basic filtering
  console.log('Applying basic filters...')
  const filteredCommits = basicFilter(allCommits)
  console.log(
    `${filteredCommits.length} commits remaining after basic filtering`,
  )

  if (filteredCommits.length === 0) {
    console.log('No commits passed basic filtering. Exiting.')
    return
  }

  // Screen commits with GPT-5
  console.log('Screening commits with GPT-5...')
  const selectedCommits = await screenCommitsWithGpt5(
    filteredCommits,
    repoUrl,
    clientSessionId,
  )
  console.log(`\nFinal selection: ${selectedCommits.length} commits`)

  // Create result object
  const result: CommitPickerResult = {
    repoUrl,
    repoName,
    generationDate: new Date().toISOString(),
    totalCommitsScanned: allCommits.length,
    commitsAfterBasicFilter: filteredCommits.length,
    selectedCommits,
  }

  // Write to file
  const generatedOutputPath =
    outputPath ||
    path.join(
      __dirname,
      `picked-commits-${repoName}-${new Date().toISOString().split('T')[0]}.json`,
    )

  fs.writeFileSync(generatedOutputPath, JSON.stringify(result, null, 2))
  console.log(`\nResults saved to: ${generatedOutputPath}`)

  // Print summary
  console.log('\n=== COMMIT PICKER SUMMARY ===')
  console.log(`Repository: ${repoUrl}`)
  console.log(`Total commits scanned: ${result.totalCommitsScanned}`)
  console.log(`After basic filtering: ${result.commitsAfterBasicFilter}`)
  console.log(`Final selection: ${result.selectedCommits.length}`)
  console.log('\nSelected commits:')
  selectedCommits.forEach((commit, index) => {
    console.log(
      `\n${index + 1}. ${commit.sha.substring(0, 8)}: ${commit.message}`,
    )
    console.log(`   URL: ${commit.githubUrl}`)
    console.log(`   Description: ${commit.shortDescription}`)
    console.log(`   Reason: ${commit.reason}`)
    console.log(
      `   Stats: ${commit.stats.filesChanged} files, +${commit.stats.insertions} -${commit.stats.deletions}`,
    )
  })
}

// CLI handling
if (require.main === module) {
  const args = process.argv.slice(2)

  if (args.length === 0) {
    console.log('Usage: bun run pick-commits <repo-url> [output-path] [limit]')
    console.log('')
    console.log('Examples:')
    console.log('  bun run pick-commits https://github.com/user/repo')
    console.log(
      '  bun run pick-commits https://github.com/user/repo ./commits.json 300',
    )
    process.exit(1)
  }

  const repoUrl = args[0]
  const outputPath = args[1]
  const limit = args[2] ? parseInt(args[2]) : 100

  if (!repoUrl) {
    console.error('Error: repo-url is required')
    process.exit(1)
  }

  // Generate random session ID for this run
  const sessionId = Math.random().toString(36).substring(2)

  pickCommits({
    repoUrl,
    outputPath,
    clientSessionId: sessionId,
    limit,
  })
    .then(() => {
      console.log('\nCommit picking completed successfully!')
      process.exit(0)
    })
    .catch((err) => {
      console.error('Error picking commits:', err)
      process.exit(1)
    })
}
